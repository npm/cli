"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundle = exports.envelopeFromJSON = exports.envelopeToJSON = exports.bundleFromJSON = exports.bundleToJSON = void 0;
const util_1 = require("../../util");
const envelope_1 = require("./__generated__/envelope");
const sigstore_bundle_1 = require("./__generated__/sigstore_bundle");
const sigstore_common_1 = require("./__generated__/sigstore_common");
__exportStar(require("./serialized"), exports);
__exportStar(require("./__generated__/envelope"), exports);
__exportStar(require("./__generated__/sigstore_bundle"), exports);
__exportStar(require("./__generated__/sigstore_common"), exports);
exports.bundleToJSON = sigstore_bundle_1.Bundle.toJSON;
exports.bundleFromJSON = sigstore_bundle_1.Bundle.fromJSON;
exports.envelopeToJSON = envelope_1.Envelope.toJSON;
exports.envelopeFromJSON = envelope_1.Envelope.fromJSON;
const BUNDLE_MEDIA_TYPE = 'application/vnd.dev.sigstore.bundle+json;version=0.1';
exports.bundle = {
    toDSSEBundle: (envelope, signature, rekorEntry) => ({
        mediaType: BUNDLE_MEDIA_TYPE,
        content: {
            $case: 'dsseEnvelope',
            dsseEnvelope: envelope,
        },
        verificationData: {
            tlogEntries: [toTransparencyLogEntry(rekorEntry)],
            timestampVerificationData: {
                rfc3161Timestamps: [],
            },
        },
        verificationMaterial: toVerificationMaterial(signature),
    }),
    toMessageSignatureBundle: (digest, signature, rekorEntry) => ({
        mediaType: BUNDLE_MEDIA_TYPE,
        content: {
            $case: 'messageSignature',
            messageSignature: {
                messageDigest: {
                    algorithm: sigstore_common_1.HashAlgorithm.SHA2_256,
                    digest: digest,
                },
                signature: signature.signature,
            },
        },
        verificationData: {
            tlogEntries: [toTransparencyLogEntry(rekorEntry)],
            timestampVerificationData: {
                rfc3161Timestamps: [],
            },
        },
        verificationMaterial: toVerificationMaterial(signature),
    }),
};
function toTransparencyLogEntry(entry) {
    const set = Buffer.from(entry.verification.signedEntryTimestamp, 'base64');
    const logID = Buffer.from(entry.logID, 'hex');
    // Parse entry body so we can extract the kind and version.
    const bodyJSON = util_1.encoding.base64Decode(entry.body);
    const entryBody = JSON.parse(bodyJSON);
    return {
        inclusionPromise: {
            signedEntryTimestamp: set,
        },
        logIndex: entry.logIndex.toString(),
        logId: {
            keyId: logID,
        },
        integratedTime: entry.integratedTime.toString(),
        kindVersion: {
            kind: entryBody.kind,
            version: entryBody.apiVersion,
        },
        inclusionProof: undefined,
    };
}
function toVerificationMaterial(signature) {
    return signature.certificates
        ? toVerificationMaterialx509CertificateChain(signature.certificates)
        : toVerificationMaterialPublicKey(signature.key.id || '');
}
function toVerificationMaterialx509CertificateChain(certificates) {
    return {
        content: {
            $case: 'x509CertificateChain',
            x509CertificateChain: {
                certificates: certificates.map((c) => ({
                    rawBytes: util_1.pem.toDER(c),
                })),
            },
        },
    };
}
function toVerificationMaterialPublicKey(hint) {
    return {
        content: {
            $case: 'publicKey',
            publicKey: { hint },
        },
    };
}
